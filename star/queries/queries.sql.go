// Code generated by pggen. DO NOT EDIT.

package queries

import (
	"context"
	"fmt"
	"github.com/jackc/pgconn"
	"github.com/jackc/pgtype"
	"github.com/jackc/pgx/v4"
)

// Querier is a typesafe Go interface backed by SQL queries.
//
// Methods ending with Batch enqueue a query to run later in a pgx.Batch. After
// calling SendBatch on pgx.Conn, pgxpool.Pool, or pgx.Tx, use the Scan methods
// to parse the results.
type Querier interface {
	ChannelConfig(ctx context.Context, channelID int64, guildID int64) (ChannelConfigRow, error)
	// ChannelConfigBatch enqueues a ChannelConfig query into batch to be executed
	// later by the batch.
	ChannelConfigBatch(batch genericBatch, channelID int64, guildID int64)
	// ChannelConfigScan scans the result of an executed ChannelConfigBatch query.
	ChannelConfigScan(results pgx.BatchResults) (ChannelConfigRow, error)

	HasOverride(ctx context.Context, channelID int64) (bool, error)
	// HasOverrideBatch enqueues a HasOverride query into batch to be executed
	// later by the batch.
	HasOverrideBatch(batch genericBatch, channelID int64)
	// HasOverrideScan scans the result of an executed HasOverrideBatch query.
	HasOverrideScan(results pgx.BatchResults) (bool, error)

	StarboardMessage(ctx context.Context, id int64) (StarboardMessageRow, error)
	// StarboardMessageBatch enqueues a StarboardMessage query into batch to be executed
	// later by the batch.
	StarboardMessageBatch(batch genericBatch, id int64)
	// StarboardMessageScan scans the result of an executed StarboardMessageBatch query.
	StarboardMessageScan(results pgx.BatchResults) (StarboardMessageRow, error)

	AddReaction(ctx context.Context, userID int64, messageID int64) (pgconn.CommandTag, error)
	// AddReactionBatch enqueues a AddReaction query into batch to be executed
	// later by the batch.
	AddReactionBatch(batch genericBatch, userID int64, messageID int64)
	// AddReactionScan scans the result of an executed AddReactionBatch query.
	AddReactionScan(results pgx.BatchResults) (pgconn.CommandTag, error)

	RemoveReaction(ctx context.Context, userID int64, messageID int64) (pgconn.CommandTag, error)
	// RemoveReactionBatch enqueues a RemoveReaction query into batch to be executed
	// later by the batch.
	RemoveReactionBatch(batch genericBatch, userID int64, messageID int64)
	// RemoveReactionScan scans the result of an executed RemoveReactionBatch query.
	RemoveReactionScan(results pgx.BatchResults) (pgconn.CommandTag, error)

	ReactionCount(ctx context.Context, messageID int64) (int64, error)
	// ReactionCountBatch enqueues a ReactionCount query into batch to be executed
	// later by the batch.
	ReactionCountBatch(batch genericBatch, messageID int64)
	// ReactionCountScan scans the result of an executed ReactionCountBatch query.
	ReactionCountScan(results pgx.BatchResults) (int64, error)

	RemoveAllReactions(ctx context.Context, messageID int64) (pgconn.CommandTag, error)
	// RemoveAllReactionsBatch enqueues a RemoveAllReactions query into batch to be executed
	// later by the batch.
	RemoveAllReactionsBatch(batch genericBatch, messageID int64)
	// RemoveAllReactionsScan scans the result of an executed RemoveAllReactionsBatch query.
	RemoveAllReactionsScan(results pgx.BatchResults) (pgconn.CommandTag, error)

	RemoveStarboard(ctx context.Context, messageID int64) (pgconn.CommandTag, error)
	// RemoveStarboardBatch enqueues a RemoveStarboard query into batch to be executed
	// later by the batch.
	RemoveStarboardBatch(batch genericBatch, messageID int64)
	// RemoveStarboardScan scans the result of an executed RemoveStarboardBatch query.
	RemoveStarboardScan(results pgx.BatchResults) (pgconn.CommandTag, error)

	InsertStarboard(ctx context.Context, params InsertStarboardParams) (InsertStarboardRow, error)
	// InsertStarboardBatch enqueues a InsertStarboard query into batch to be executed
	// later by the batch.
	InsertStarboardBatch(batch genericBatch, params InsertStarboardParams)
	// InsertStarboardScan scans the result of an executed InsertStarboardBatch query.
	InsertStarboardScan(results pgx.BatchResults) (InsertStarboardRow, error)

	GetStarboard(ctx context.Context, messageID int64) (GetStarboardRow, error)
	// GetStarboardBatch enqueues a GetStarboard query into batch to be executed
	// later by the batch.
	GetStarboardBatch(batch genericBatch, messageID int64)
	// GetStarboardScan scans the result of an executed GetStarboardBatch query.
	GetStarboardScan(results pgx.BatchResults) (GetStarboardRow, error)
}

type DBQuerier struct {
	conn  genericConn   // underlying Postgres transport to use
	types *typeResolver // resolve types by name
}

var _ Querier = &DBQuerier{}

// genericConn is a connection to a Postgres database. This is usually backed by
// *pgx.Conn, pgx.Tx, or *pgxpool.Pool.
type genericConn interface {
	// Query executes sql with args. If there is an error the returned Rows will
	// be returned in an error state. So it is allowed to ignore the error
	// returned from Query and handle it in Rows.
	Query(ctx context.Context, sql string, args ...interface{}) (pgx.Rows, error)

	// QueryRow is a convenience wrapper over Query. Any error that occurs while
	// querying is deferred until calling Scan on the returned Row. That Row will
	// error with pgx.ErrNoRows if no rows are returned.
	QueryRow(ctx context.Context, sql string, args ...interface{}) pgx.Row

	// Exec executes sql. sql can be either a prepared statement name or an SQL
	// string. arguments should be referenced positionally from the sql string
	// as $1, $2, etc.
	Exec(ctx context.Context, sql string, arguments ...interface{}) (pgconn.CommandTag, error)
}

// genericBatch batches queries to send in a single network request to a
// Postgres server. This is usually backed by *pgx.Batch.
type genericBatch interface {
	// Queue queues a query to batch b. query can be an SQL query or the name of a
	// prepared statement. See Queue on *pgx.Batch.
	Queue(query string, arguments ...interface{})
}

// NewQuerier creates a DBQuerier that implements Querier. conn is typically
// *pgx.Conn, pgx.Tx, or *pgxpool.Pool.
func NewQuerier(conn genericConn) *DBQuerier {
	return NewQuerierConfig(conn, QuerierConfig{})
}

type QuerierConfig struct {
	// DataTypes contains pgtype.Value to use for encoding and decoding instead
	// of pggen-generated pgtype.ValueTranscoder.
	//
	// If OIDs are available for an input parameter type and all of its
	// transitive dependencies, pggen will use the binary encoding format for
	// the input parameter.
	DataTypes []pgtype.DataType
}

// NewQuerierConfig creates a DBQuerier that implements Querier with the given
// config. conn is typically *pgx.Conn, pgx.Tx, or *pgxpool.Pool.
func NewQuerierConfig(conn genericConn, cfg QuerierConfig) *DBQuerier {
	return &DBQuerier{conn: conn, types: newTypeResolver(cfg.DataTypes)}
}

// WithTx creates a new DBQuerier that uses the transaction to run all queries.
func (q *DBQuerier) WithTx(tx pgx.Tx) (*DBQuerier, error) {
	return &DBQuerier{conn: tx}, nil
}

// preparer is any Postgres connection transport that provides a way to prepare
// a statement, most commonly *pgx.Conn.
type preparer interface {
	Prepare(ctx context.Context, name, sql string) (sd *pgconn.StatementDescription, err error)
}

// PrepareAllQueries executes a PREPARE statement for all pggen generated SQL
// queries in querier files. Typical usage is as the AfterConnect callback
// for pgxpool.Config
//
// pgx will use the prepared statement if available. Calling PrepareAllQueries
// is an optional optimization to avoid a network round-trip the first time pgx
// runs a query if pgx statement caching is enabled.
func PrepareAllQueries(ctx context.Context, p preparer) error {
	if _, err := p.Prepare(ctx, channelConfigSQL, channelConfigSQL); err != nil {
		return fmt.Errorf("prepare query 'ChannelConfig': %w", err)
	}
	if _, err := p.Prepare(ctx, hasOverrideSQL, hasOverrideSQL); err != nil {
		return fmt.Errorf("prepare query 'HasOverride': %w", err)
	}
	if _, err := p.Prepare(ctx, starboardMessageSQL, starboardMessageSQL); err != nil {
		return fmt.Errorf("prepare query 'StarboardMessage': %w", err)
	}
	if _, err := p.Prepare(ctx, addReactionSQL, addReactionSQL); err != nil {
		return fmt.Errorf("prepare query 'AddReaction': %w", err)
	}
	if _, err := p.Prepare(ctx, removeReactionSQL, removeReactionSQL); err != nil {
		return fmt.Errorf("prepare query 'RemoveReaction': %w", err)
	}
	if _, err := p.Prepare(ctx, reactionCountSQL, reactionCountSQL); err != nil {
		return fmt.Errorf("prepare query 'ReactionCount': %w", err)
	}
	if _, err := p.Prepare(ctx, removeAllReactionsSQL, removeAllReactionsSQL); err != nil {
		return fmt.Errorf("prepare query 'RemoveAllReactions': %w", err)
	}
	if _, err := p.Prepare(ctx, removeStarboardSQL, removeStarboardSQL); err != nil {
		return fmt.Errorf("prepare query 'RemoveStarboard': %w", err)
	}
	if _, err := p.Prepare(ctx, insertStarboardSQL, insertStarboardSQL); err != nil {
		return fmt.Errorf("prepare query 'InsertStarboard': %w", err)
	}
	if _, err := p.Prepare(ctx, getStarboardSQL, getStarboardSQL); err != nil {
		return fmt.Errorf("prepare query 'GetStarboard': %w", err)
	}
	return nil
}

// typeResolver looks up the pgtype.ValueTranscoder by Postgres type name.
type typeResolver struct {
	connInfo *pgtype.ConnInfo // types by Postgres type name
}

func newTypeResolver(types []pgtype.DataType) *typeResolver {
	ci := pgtype.NewConnInfo()
	for _, typ := range types {
		if txt, ok := typ.Value.(textPreferrer); ok && typ.OID != unknownOID {
			typ.Value = txt.ValueTranscoder
		}
		ci.RegisterDataType(typ)
	}
	return &typeResolver{connInfo: ci}
}

// findValue find the OID, and pgtype.ValueTranscoder for a Postgres type name.
func (tr *typeResolver) findValue(name string) (uint32, pgtype.ValueTranscoder, bool) {
	typ, ok := tr.connInfo.DataTypeForName(name)
	if !ok {
		return 0, nil, false
	}
	v := pgtype.NewValue(typ.Value)
	return typ.OID, v.(pgtype.ValueTranscoder), true
}

// setValue sets the value of a ValueTranscoder to a value that should always
// work and panics if it fails.
func (tr *typeResolver) setValue(vt pgtype.ValueTranscoder, val interface{}) pgtype.ValueTranscoder {
	if err := vt.Set(val); err != nil {
		panic(fmt.Sprintf("set ValueTranscoder %T to %+v: %s", vt, val, err))
	}
	return vt
}

const channelConfigSQL = `select
coalesce(o.starboard, s.channel_id) as starboard,
coalesce(o.disabled, false) as disabled,
coalesce(o.emoji, s.emoji) as emoji,
coalesce(o.reaction_limit, s.reaction_limit) as reaction_limit,
s.allow_self_star as allow_self_star
from starboard s
left outer join starboard_overrides o on o.channel_id = $1
where s.guild_id = $2
limit 1;`

type ChannelConfigRow struct {
	Starboard     int64  `json:"starboard"`
	Disabled      bool   `json:"disabled"`
	Emoji         string `json:"emoji"`
	ReactionLimit int    `json:"reaction_limit"`
	AllowSelfStar bool   `json:"allow_self_star"`
}

// ChannelConfig implements Querier.ChannelConfig.
func (q *DBQuerier) ChannelConfig(ctx context.Context, channelID int64, guildID int64) (ChannelConfigRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "ChannelConfig")
	row := q.conn.QueryRow(ctx, channelConfigSQL, channelID, guildID)
	var item ChannelConfigRow
	if err := row.Scan(&item.Starboard, &item.Disabled, &item.Emoji, &item.ReactionLimit, &item.AllowSelfStar); err != nil {
		return item, fmt.Errorf("query ChannelConfig: %w", err)
	}
	return item, nil
}

// ChannelConfigBatch implements Querier.ChannelConfigBatch.
func (q *DBQuerier) ChannelConfigBatch(batch genericBatch, channelID int64, guildID int64) {
	batch.Queue(channelConfigSQL, channelID, guildID)
}

// ChannelConfigScan implements Querier.ChannelConfigScan.
func (q *DBQuerier) ChannelConfigScan(results pgx.BatchResults) (ChannelConfigRow, error) {
	row := results.QueryRow()
	var item ChannelConfigRow
	if err := row.Scan(&item.Starboard, &item.Disabled, &item.Emoji, &item.ReactionLimit, &item.AllowSelfStar); err != nil {
		return item, fmt.Errorf("scan ChannelConfigBatch row: %w", err)
	}
	return item, nil
}

const hasOverrideSQL = `select exists(select channel_id from starboard_overrides where channel_id = $1);`

// HasOverride implements Querier.HasOverride.
func (q *DBQuerier) HasOverride(ctx context.Context, channelID int64) (bool, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "HasOverride")
	row := q.conn.QueryRow(ctx, hasOverrideSQL, channelID)
	var item bool
	if err := row.Scan(&item); err != nil {
		return item, fmt.Errorf("query HasOverride: %w", err)
	}
	return item, nil
}

// HasOverrideBatch implements Querier.HasOverrideBatch.
func (q *DBQuerier) HasOverrideBatch(batch genericBatch, channelID int64) {
	batch.Queue(hasOverrideSQL, channelID)
}

// HasOverrideScan implements Querier.HasOverrideScan.
func (q *DBQuerier) HasOverrideScan(results pgx.BatchResults) (bool, error) {
	row := results.QueryRow()
	var item bool
	if err := row.Scan(&item); err != nil {
		return item, fmt.Errorf("scan HasOverrideBatch row: %w", err)
	}
	return item, nil
}

const starboardMessageSQL = `select * from starboard_messages
where message_id = $1 or starboard_id = $1;`

type StarboardMessageRow struct {
	MessageID   int64 `json:"message_id"`
	ChannelID   int64 `json:"channel_id"`
	GuildID     int64 `json:"guild_id"`
	StarboardID int64 `json:"starboard_id"`
}

// StarboardMessage implements Querier.StarboardMessage.
func (q *DBQuerier) StarboardMessage(ctx context.Context, id int64) (StarboardMessageRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "StarboardMessage")
	row := q.conn.QueryRow(ctx, starboardMessageSQL, id)
	var item StarboardMessageRow
	if err := row.Scan(&item.MessageID, &item.ChannelID, &item.GuildID, &item.StarboardID); err != nil {
		return item, fmt.Errorf("query StarboardMessage: %w", err)
	}
	return item, nil
}

// StarboardMessageBatch implements Querier.StarboardMessageBatch.
func (q *DBQuerier) StarboardMessageBatch(batch genericBatch, id int64) {
	batch.Queue(starboardMessageSQL, id)
}

// StarboardMessageScan implements Querier.StarboardMessageScan.
func (q *DBQuerier) StarboardMessageScan(results pgx.BatchResults) (StarboardMessageRow, error) {
	row := results.QueryRow()
	var item StarboardMessageRow
	if err := row.Scan(&item.MessageID, &item.ChannelID, &item.GuildID, &item.StarboardID); err != nil {
		return item, fmt.Errorf("scan StarboardMessageBatch row: %w", err)
	}
	return item, nil
}

const addReactionSQL = `insert into starboard_reactions (user_id, message_id) values ($1, $2) on conflict (user_id, message_id) do nothing;`

// AddReaction implements Querier.AddReaction.
func (q *DBQuerier) AddReaction(ctx context.Context, userID int64, messageID int64) (pgconn.CommandTag, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "AddReaction")
	cmdTag, err := q.conn.Exec(ctx, addReactionSQL, userID, messageID)
	if err != nil {
		return cmdTag, fmt.Errorf("exec query AddReaction: %w", err)
	}
	return cmdTag, err
}

// AddReactionBatch implements Querier.AddReactionBatch.
func (q *DBQuerier) AddReactionBatch(batch genericBatch, userID int64, messageID int64) {
	batch.Queue(addReactionSQL, userID, messageID)
}

// AddReactionScan implements Querier.AddReactionScan.
func (q *DBQuerier) AddReactionScan(results pgx.BatchResults) (pgconn.CommandTag, error) {
	cmdTag, err := results.Exec()
	if err != nil {
		return cmdTag, fmt.Errorf("exec AddReactionBatch: %w", err)
	}
	return cmdTag, err
}

const removeReactionSQL = `delete from starboard_reactions where user_id = $1 and message_id = $2;`

// RemoveReaction implements Querier.RemoveReaction.
func (q *DBQuerier) RemoveReaction(ctx context.Context, userID int64, messageID int64) (pgconn.CommandTag, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "RemoveReaction")
	cmdTag, err := q.conn.Exec(ctx, removeReactionSQL, userID, messageID)
	if err != nil {
		return cmdTag, fmt.Errorf("exec query RemoveReaction: %w", err)
	}
	return cmdTag, err
}

// RemoveReactionBatch implements Querier.RemoveReactionBatch.
func (q *DBQuerier) RemoveReactionBatch(batch genericBatch, userID int64, messageID int64) {
	batch.Queue(removeReactionSQL, userID, messageID)
}

// RemoveReactionScan implements Querier.RemoveReactionScan.
func (q *DBQuerier) RemoveReactionScan(results pgx.BatchResults) (pgconn.CommandTag, error) {
	cmdTag, err := results.Exec()
	if err != nil {
		return cmdTag, fmt.Errorf("exec RemoveReactionBatch: %w", err)
	}
	return cmdTag, err
}

const reactionCountSQL = `select count(*) from starboard_reactions where message_id = $1;`

// ReactionCount implements Querier.ReactionCount.
func (q *DBQuerier) ReactionCount(ctx context.Context, messageID int64) (int64, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "ReactionCount")
	row := q.conn.QueryRow(ctx, reactionCountSQL, messageID)
	var item int64
	if err := row.Scan(&item); err != nil {
		return item, fmt.Errorf("query ReactionCount: %w", err)
	}
	return item, nil
}

// ReactionCountBatch implements Querier.ReactionCountBatch.
func (q *DBQuerier) ReactionCountBatch(batch genericBatch, messageID int64) {
	batch.Queue(reactionCountSQL, messageID)
}

// ReactionCountScan implements Querier.ReactionCountScan.
func (q *DBQuerier) ReactionCountScan(results pgx.BatchResults) (int64, error) {
	row := results.QueryRow()
	var item int64
	if err := row.Scan(&item); err != nil {
		return item, fmt.Errorf("scan ReactionCountBatch row: %w", err)
	}
	return item, nil
}

const removeAllReactionsSQL = `delete from starboard_reactions where message_id = $1;`

// RemoveAllReactions implements Querier.RemoveAllReactions.
func (q *DBQuerier) RemoveAllReactions(ctx context.Context, messageID int64) (pgconn.CommandTag, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "RemoveAllReactions")
	cmdTag, err := q.conn.Exec(ctx, removeAllReactionsSQL, messageID)
	if err != nil {
		return cmdTag, fmt.Errorf("exec query RemoveAllReactions: %w", err)
	}
	return cmdTag, err
}

// RemoveAllReactionsBatch implements Querier.RemoveAllReactionsBatch.
func (q *DBQuerier) RemoveAllReactionsBatch(batch genericBatch, messageID int64) {
	batch.Queue(removeAllReactionsSQL, messageID)
}

// RemoveAllReactionsScan implements Querier.RemoveAllReactionsScan.
func (q *DBQuerier) RemoveAllReactionsScan(results pgx.BatchResults) (pgconn.CommandTag, error) {
	cmdTag, err := results.Exec()
	if err != nil {
		return cmdTag, fmt.Errorf("exec RemoveAllReactionsBatch: %w", err)
	}
	return cmdTag, err
}

const removeStarboardSQL = `delete from starboard_messages where message_id = $1
or starboard_id = $1;`

// RemoveStarboard implements Querier.RemoveStarboard.
func (q *DBQuerier) RemoveStarboard(ctx context.Context, messageID int64) (pgconn.CommandTag, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "RemoveStarboard")
	cmdTag, err := q.conn.Exec(ctx, removeStarboardSQL, messageID)
	if err != nil {
		return cmdTag, fmt.Errorf("exec query RemoveStarboard: %w", err)
	}
	return cmdTag, err
}

// RemoveStarboardBatch implements Querier.RemoveStarboardBatch.
func (q *DBQuerier) RemoveStarboardBatch(batch genericBatch, messageID int64) {
	batch.Queue(removeStarboardSQL, messageID)
}

// RemoveStarboardScan implements Querier.RemoveStarboardScan.
func (q *DBQuerier) RemoveStarboardScan(results pgx.BatchResults) (pgconn.CommandTag, error) {
	cmdTag, err := results.Exec()
	if err != nil {
		return cmdTag, fmt.Errorf("exec RemoveStarboardBatch: %w", err)
	}
	return cmdTag, err
}

const insertStarboardSQL = `insert into starboard_messages
(message_id, channel_id, guild_id, starboard_id)
values (
    $1,
    $2,
    $3,
    $4
) returning *;`

type InsertStarboardParams struct {
	MessageID   int64
	ChannelID   int64
	GuildID     int64
	StarboardID int64
}

type InsertStarboardRow struct {
	MessageID   int64 `json:"message_id"`
	ChannelID   int64 `json:"channel_id"`
	GuildID     int64 `json:"guild_id"`
	StarboardID int64 `json:"starboard_id"`
}

// InsertStarboard implements Querier.InsertStarboard.
func (q *DBQuerier) InsertStarboard(ctx context.Context, params InsertStarboardParams) (InsertStarboardRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "InsertStarboard")
	row := q.conn.QueryRow(ctx, insertStarboardSQL, params.MessageID, params.ChannelID, params.GuildID, params.StarboardID)
	var item InsertStarboardRow
	if err := row.Scan(&item.MessageID, &item.ChannelID, &item.GuildID, &item.StarboardID); err != nil {
		return item, fmt.Errorf("query InsertStarboard: %w", err)
	}
	return item, nil
}

// InsertStarboardBatch implements Querier.InsertStarboardBatch.
func (q *DBQuerier) InsertStarboardBatch(batch genericBatch, params InsertStarboardParams) {
	batch.Queue(insertStarboardSQL, params.MessageID, params.ChannelID, params.GuildID, params.StarboardID)
}

// InsertStarboardScan implements Querier.InsertStarboardScan.
func (q *DBQuerier) InsertStarboardScan(results pgx.BatchResults) (InsertStarboardRow, error) {
	row := results.QueryRow()
	var item InsertStarboardRow
	if err := row.Scan(&item.MessageID, &item.ChannelID, &item.GuildID, &item.StarboardID); err != nil {
		return item, fmt.Errorf("scan InsertStarboardBatch row: %w", err)
	}
	return item, nil
}

const getStarboardSQL = `select * from starboard_messages
where message_id = $1
or starboard_id = $1;`

type GetStarboardRow struct {
	MessageID   int64 `json:"message_id"`
	ChannelID   int64 `json:"channel_id"`
	GuildID     int64 `json:"guild_id"`
	StarboardID int64 `json:"starboard_id"`
}

// GetStarboard implements Querier.GetStarboard.
func (q *DBQuerier) GetStarboard(ctx context.Context, messageID int64) (GetStarboardRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "GetStarboard")
	row := q.conn.QueryRow(ctx, getStarboardSQL, messageID)
	var item GetStarboardRow
	if err := row.Scan(&item.MessageID, &item.ChannelID, &item.GuildID, &item.StarboardID); err != nil {
		return item, fmt.Errorf("query GetStarboard: %w", err)
	}
	return item, nil
}

// GetStarboardBatch implements Querier.GetStarboardBatch.
func (q *DBQuerier) GetStarboardBatch(batch genericBatch, messageID int64) {
	batch.Queue(getStarboardSQL, messageID)
}

// GetStarboardScan implements Querier.GetStarboardScan.
func (q *DBQuerier) GetStarboardScan(results pgx.BatchResults) (GetStarboardRow, error) {
	row := results.QueryRow()
	var item GetStarboardRow
	if err := row.Scan(&item.MessageID, &item.ChannelID, &item.GuildID, &item.StarboardID); err != nil {
		return item, fmt.Errorf("scan GetStarboardBatch row: %w", err)
	}
	return item, nil
}

// textPreferrer wraps a pgtype.ValueTranscoder and sets the preferred encoding
// format to text instead binary (the default). pggen uses the text format
// when the OID is unknownOID because the binary format requires the OID.
// Typically occurs if the results from QueryAllDataTypes aren't passed to
// NewQuerierConfig.
type textPreferrer struct {
	pgtype.ValueTranscoder
	typeName string
}

// PreferredParamFormat implements pgtype.ParamFormatPreferrer.
func (t textPreferrer) PreferredParamFormat() int16 { return pgtype.TextFormatCode }

func (t textPreferrer) NewTypeValue() pgtype.Value {
	return textPreferrer{pgtype.NewValue(t.ValueTranscoder).(pgtype.ValueTranscoder), t.typeName}
}

func (t textPreferrer) TypeName() string {
	return t.typeName
}

// unknownOID means we don't know the OID for a type. This is okay for decoding
// because pgx call DecodeText or DecodeBinary without requiring the OID. For
// encoding parameters, pggen uses textPreferrer if the OID is unknown.
const unknownOID = 0
